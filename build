#!/bin/bash
# Script to build a package.  It uses init_buildsystem to setup a chroot
# building tree.  This script needs a directory as parameter.  This directory
# has to include sources and a spec file.
#
# BUILD_ROOT        here the packages will be built
#
# (c) 1997-2008 SuSE GmbH Nuernberg, Germany

# 用法示例：
# env BUILD_RPMS=/dist/mithras/mithras/build/BUILD/x86_64/GTES/ build --clean --dist gtes11.3
# BUILD_RPMS 指定一个仓库（包含足够的软件包）路径
# --clean 清理先前的 BUILD_ROOT
# --dist gtes11.3  使用 gtes11.3.conf 文件初始化 BUILD_ROOT

# 下面设置一些变量和定义一些函数，脚本“真正”开始从 "#### main ####" 处。

# 设置 BUILD_DIR 和 BUILD_ROOT
# BUILD_DIR 是 build 程序安装到哪里了，这下面有 configs 目录
# BUILD_ROOT  是将要建立 chroot 环境的目录
test -z "$BUILD_DIR" && BUILD_DIR=/usr/lib/build
test -z "$BUILD_ROOT" && BUILD_ROOT=/var/tmp/build-root

export BUILD_ARCH BUILD_HOST_ARCH BUILD_ROOT BUILD_RPMS BUILD_DIR

ccache=0
icecream=0
definesnstuff=()
repos=()

# mkreiserfs only works with qemu/uml if it is able to create a file
# system that is owned by the calling user (bnc#369006)
#vm_img_mkfs='mkreiserfs -q -f'
#vm_img_mkfs='mkfs.ext2 -m 0 -q -F'
vm_img_mkfs='mkfs.ext3 -m 0 -q -F'
vm_img_tunefs='tune2fs -c 0'
qemu_kernel=/boot/vmlinuz
qemu_initrd=/boot/initrd
qemu_bin=/usr/bin/qemu
uml_kernel=/boot/vmlinux-um
uml_initrd=/boot/initrd-um

kvm_kernel=/boot/vmlinuz
kvm_initrd=/boot/initrd
kvm_bin=/usr/bin/qemu-kvm
mkinitrd_virtio_cmd=(env rootfstype=ext3 mkinitrd -d /dev/null -m "virtio_pci virtio_blk" -k $kvm_kernel -i $kvm_initrd-virtio)
# whether we have virtio support
kvm_virtio=

DO_INIT=true
DO_LINT=
DO_CHECKS=true
CLEAN_BUILD=
SPECFILES=()
SRCDIR=
BUILD_JOBS=
ABUILD_TARGET_ARCH=
CREATE_BASELIBS=
USEUSEDFORBUILD=
LIST_STATE=
VM_IMAGE=
VM_SWAP=
MEMSIZE=
RUNNING_IN_VM=
RPMLIST=
RELEASE=
REASON=
NOROOTFORBUILD=
LOGFILE=
KILL=
CHANGELOG=
BUILD_DEBUG=
PERSONALITY_SYSCALL=
INCARNATION=
DISTURL=
CHANGETARGET=
OVERLAY=
RSYNCSRC=
RSYNCDEST=
RSYNCDONE=

export PATH=$BUILD_DIR:/sbin:/usr/sbin:$PATH

# This is for insserv
export YAST_IS_RUNNING=instsys

unset LANGUAGE
unset LANG
export LC_ALL=POSIX
umask 022

echo_help () {
    cat << EOT

Some comments for build
-----------------------

With build you can create rpm packages.  They will be built in a chroot
system.  This chroot system will be setup automatically.  Normally you can
simply call build with a spec file as parameter - nothing else has to be
set.

If you want to set the directory were the chroot system will be setup
(at the moment it uses $BUILD_ROOT),
simply set the the environment variable BUILD_ROOT.

Example:

  export BUILD_ROOT=/var/tmp/mybuildroot


Normally build builds the complete package including src.rpm (rpmbuild -ba).
If you want let build only make the binary package, simply set

   export BUILD_RPM_BUILD_STAGE=-bb

(or -bc, -bp, -bi, ...  see "Maximum RPM" for more details [*]).

When the build command succeeds, the rpm files can be found under
$BUILD_ROOT/usr/src/packages/RPMS/


Known Parameters:

  --help      You already got it :)

  --clean     Delete old build root before initializing it

  --no-init   Skip initialization of build root and start with build
              immediately.

  --no-checks Do not run post-build checks

  --rpms path1:path2:...
              Specify path where to find the RPMs for the build system

  --arch arch1:arch2:...
              Specify what architectures to select from the RPMs

  --useusedforbuild
              Do not expand dependencies but search the specfile for
              usedforbuild lines.

  --verify    Run verify when initializing the build root

  --extra-packs pack
              Also install package 'pack'

  --root rootdir
              Use 'rootdir' to setup chroot environment

  --oldpackages oldpackagesdir
              Define a directory with a former build

  --baselibs  Create -32bit/-64bit/-x86 rpms for other architectures

  --list-state
              List rpms that would be used to create a fresh build root.
              Does not create the build root or perform a build.

  --with X
              enable feature X for build

  --without X
              disable feature X for build

  --define 'X Y'
              define macro X with value Y

  --ccache
              use ccache to speed up rebuilds

  --icecream N
              use N parallel build jobs with icecream
  --overlay OVERLAY
              Copy overlay filesystem to buildroot after installing
              all RPMs. This must be a valid directory.

  --rsync-src RSYNCSRC
              Copy overlay folder (RSYNCSRC) to a folder (RSYNCDEST)
              inside the buildroot using rsync.
              It will "%define RSYNCDONE 1" for handling %setup in your
              specfile. E.g.:
              %prep
              %if 0%{?RSYNCDONE}
              %setup -n aaa_base -T -D -b 5 -b 7
              %else
              %setup -n aaa_base -b 5 -b 7
              %endif

  --rsync-dest RSYNCDEST
              Copy overlay folder (RSYNCSRC) to a folder (RSYNCDEST)
              inside the buildroot using rsync.

  --debug
              enable creation of a debuginfo package

Remember to have fun!

[*] Maximum RPM: http://www.rpm.org/max-rpm/
EOT
}
usage () {
    echo "Usage: `basename $0` [--no-init|--clean|--rpms path|--verify|--help] [dir-to-build|spec-to-build]"
    cleanup_and_exit 1
}

#
#  cleanup_and_exit
#  return values: 0 -> success, new packages built
#                 1 -> error, build failed
#                 2 -> successfull build, but no changes to former built packages
#
cleanup_and_exit () {
    # 这个重要！ trap 直接跟信号名字，表示用该信号默认的动作处理，
    # 这里是恢复 EXIT 信号的动作，因为前面程序有 "trap fail_exit EXIT" 
    trap EXIT
    test -z "$1" && set 0
    # 如果在虚拟机中
    if test -n "$RUNNING_IN_VM" ; then
	cd /
	if test -n "$VM_SWAP" -a -e "$VM_SWAP" ; then
	    swapoff "$VM_SWAP" 2>/dev/null
	    echo -n "BUILDSTATUS$1" >"$VM_SWAP"
	fi
        # 0 是标准输出, 2 是标准错误输出
        # 下面命令把当前“输出”重定向到标准输出,"标准错误输出" 也指向标准输出
        # 因为程序执行中，是可能改变这些的，现在只是恢复。
	exec >&0 2>&0	# so that the logging tee finishes
	sleep 1		# wait till tee terminates
        # kill 中指定 -1 为 pid 值，表示所有大于 1 的进程都将得到指定的信号
        # -1     All processes with pid larger than 1 will be signaled.
	kill -9 -1	# goodbye cruel world
        # "halt -f -p" 强制关机并断点
        # -f     Force halt or reboot, don’t call shutdown(8).
        # -p     When halting the system, do a poweroff. This is the  default  when  halt  is  called as poweroff.
	exec /bin/bash -c 'mount -n -o remount,ro / ; halt -f -p'
	halt -f -p
    else
    # 不在虚拟机中
	umount -n $BUILD_ROOT/proc 2>/dev/null || true
	umount -n $BUILD_ROOT/dev/pts 2>/dev/null || true
	test "$VM_IMAGE" = 1 && VM_IMAGE=
	[ -n "$VM_IMAGE" ] && umount $BUILD_ROOT 2>/dev/null || true
    fi
    exit $1
}

# 接受到 EXIT 信号时的处理函数， "man exit" 可以看到 bash 内置命令的帮助手册
# exit [n]
#              Cause  the shell to exit with a status of n.  If n is omitted, the exit sta-
#              tus is that of the last command executed.  A trap on EXIT is executed before
#              the shell terminates.
# exit 函数会发出 EXIT 信号
# 注意 cleanup_and_exit 函数中恢复了 EXIT 的默认动作，才不会循环执行！
fail_exit()
{
  cleanup_and_exit 1
}

shellquote()
{
    for arg; do
	arg=${arg/\\/\\\\}
	arg=${arg/\$/\\\$}
	arg=${arg/\"/\\\"}
	arg=${arg/\`/\\\`}
	echo -n " \"$arg\""
    done
}

# create a shell script from command line. Used for preserving arguments
# through /bin/su -c
toshellscript()
{
	echo "#!/bin/sh -x"
	echo -n exec
	shellquote "$@"
	echo
}

# http://ccache.samba.org/
# 加快 c/c++ 编译速度
setupccache()
{
    if [ "$ccache" = 1 ]; then
	if mkdir -p $BUILD_ROOT/var/lib/build/ccache/bin; then
	    for i in gcc g++ cc c++; do
#		ln -sf /usr/bin/ccache $BUILD_ROOT/var/lib/build/ccache/bin/$i
		rm -f $BUILD_ROOT/var/lib/build/ccache/bin/$i
		test -e $BUILD_ROOT/usr/bin/$i || continue
		echo '#! /bin/sh' > $BUILD_ROOT/var/lib/build/ccache/bin/$i
		echo "test -e /usr/bin/$i || exit 1" >> $BUILD_ROOT/var/lib/build/ccache/bin/$i
	        echo 'export PATH=/opt/icecream/bin:/usr/bin:$PATH' >> $BUILD_ROOT/var/lib/build/ccache/bin/$i
		echo "ccache $i \"\$@\"" >> $BUILD_ROOT/var/lib/build/ccache/bin/$i
		chmod 755 $BUILD_ROOT/var/lib/build/ccache/bin/$i
		echo "Installed ccache wrapper as $BUILD_ROOT/var/lib/build/ccache/bin/$i"
	    done
	fi
	mkdir -p "$BUILD_ROOT"/.ccache
	chroot "$BUILD_ROOT" chown -R "$BUILD_USER" "/.ccache"
	echo "export CCACHE_DIR=/.ccache" > "$BUILD_ROOT"/etc/profile.d/build_ccache.sh
	echo 'export PATH=/var/lib/build/ccache/bin:$PATH' >> "$BUILD_ROOT"/etc/profile.d/build_ccache.sh
    else
	rm -f "$BUILD_ROOT$builduserhome"/bin/{gcc,g++,cc,c++}
	rm -f "$BUILD_ROOT"/var/lib/build/ccache/bin/{gcc,g++,cc,c++}
    fi
}

# 参考： http://en.opensuse.org/Icecream
# icecream 是建立 distcc 基础上的软件，可以分布式编译，此处创建 icecream 环境
setupicecream()
{
    if [ "$icecream" -eq 0 ]; then
	rm -rf "$BUILD_ROOT"/var/run/icecream
	rm -f "$BUILD_ROOT"/etc/profile.d/build_icecream.sh
	return
    fi

    if ! chroot "$BUILD_ROOT" rpm -q icecream >/dev/null 2>/dev/null; then
	echo "*** icecream package not installed ***"
	false
	return
    fi

    echo "using icecream with $icecream jobs"

    if [ "$ccache" -ne 1 ]; then
	echo 'export PATH=/opt/icecream/bin:$PATH' > "$BUILD_ROOT"/etc/profile.d/build_icecream.sh
    else
	echo 'export CCACHE_PATH=/opt/icecream/bin' > "$BUILD_ROOT"/etc/profile.d/build_icecream.sh
    fi

    local icecc_vers=(`shopt -s nullglob; echo $BUILD_ROOT/var/run/icecream/*.tar.{bz2,gz}`)
    icecc_vers=${icecc_vers//$BUILD_ROOT/}

    # XXX use changelog like autobuild does instead?
    # only run create-env if compiler or glibc changed
    if [ -z "$icecc_vers" \
	-o ! -e "$BUILD_ROOT/$icecc_vers" \
	-o "$BUILD_ROOT/usr/bin/gcc" -nt "$BUILD_ROOT/$icecc_vers" \
	-o "$BUILD_ROOT/usr/bin/g++" -nt "$BUILD_ROOT/$icecc_vers" \
	-o "$BUILD_ROOT/usr/bin/as" -nt "$BUILD_ROOT/$icecc_vers" \
	-o "$BUILD_ROOT/lib/libc.so.6" -nt "$BUILD_ROOT/$icecc_vers" ]
    then
	rm -rf $BUILD_ROOT/var/run/icecream
	mkdir -p $BUILD_ROOT/var/run/icecream
	if [ -e "$BUILD_ROOT"/usr/bin/create-env ]; then
	  createenv=/usr/bin/create-env
	elif [ -e "$BUILD_ROOT"/usr/lib/icecc/icecc-create-env ]; then
	  createenv="/usr/lib/icecc/icecc-create-env /usr/bin/gcc /usr/bin/g++" # XXX
	elif [ -e "$BUILD_ROOT"/usr/lib64/icecc/icecc-create-env ]; then
	  createenv="/usr/lib64/icecc/icecc-create-env /usr/bin/gcc /usr/bin/g++" # XXX
	else
	  echo "create-env not found"
	  false
	  return
	fi
	chroot $BUILD_ROOT bash -c "cd /var/run/icecream; $createenv" || cleanup_and_exit 1
	icecc_vers=(`shopt -s nullglob; echo $BUILD_ROOT/var/run/icecream/*.tar.{bz2,gz}`)
	icecc_vers=${icecc_vers//$BUILD_ROOT/}
    else
	echo "reusing existing icecream environment $icecc_vers"
    fi
    if [ -n "$icecc_vers" ]; then
      echo "export ICECC_VERSION=$icecc_vers" >> "$BUILD_ROOT"/etc/profile.d/build_icecream.sh
    fi
}

# 设置虚拟内存限额
setmemorylimit()
{
    if [ -n "$VM_IMAGE" -o -n "$RUNNING_IN_VM" ]; then
	return
    fi
    local mem
    while read mem; do
	case "$mem" in
	    MemTotal:*)
                #  把 $mem 字符串设置为命令行参数
		set -- $mem
                eval "mem=\$(($2/3*4))"
                # 使用 "ulimit -a" 可以看到 "virtual memory (kbytes,
                # -v) unlimited" ，说明 -v 设置 虚拟内存限额。
		ulimit -v $mem
		echo "Memory limit set to ${mem}KB"
		break;
	    ;;
	esac
    done < <(cat /proc/meminfo) # cat for proc stuff
}

function create_baselibs {
    echo "... creating baselibs"
    BRPMS=
    for RPM in $BUILD_ROOT$TOPDIR/RPMS/*/*.rpm ; do
        BRPMS="$BRPMS ${RPM#$BUILD_ROOT}"
    done
    BDEBS=
    for DEB in $BUILD_ROOT$TOPDIR/DEBS/*.deb ; do
        BDEBS="$BDEBS ${DEB#$BUILD_ROOT}"
    done
    BASELIBS_CFG=
## Nb REPO is the name of the project instance
## DISTRO is the underlying (remote?) distro
#    if test -e $BUILD_ROOT$TOPDIR/SOURCES/baselibs_${REPO}.conf ; then
#	BASELIBS_CFG="-c $TOPDIR/SOURCES/baselibs_${REPO}.conf"
#    elif test -e $BUILD_ROOT$TOPDIR/SOURCES/baselibs_${DISTRO}.conf ; then
#	BASELIBS_CFG="-c $TOPDIR/SOURCES/baselibs_${DISTRO}.conf"
#    elif test -e $BUILD_ROOT$TOPDIR/SOURCES/baselibs.conf ; then

    if test "$BUILDTYPE" == "dsc" ; then
	BPKGS=$BDEBS
    else # spec and kiwi
	if test -e $BUILD_ROOT$TOPDIR/SOURCES/baselibs.conf ; then
	    BASELIBS_CFG="-c $TOPDIR/SOURCES/baselibs.conf"
	fi
	if test -e $BUILD_ROOT/usr/lib/build/baselibs_global.conf; then
	    BASELIBS_GLOBAL="-c /usr/lib/build/baselibs_global.conf"
	fi
	BPKGS=$BRPMS
    fi
    if test -f $BUILD_ROOT/usr/lib/build/mkbaselibs ; then
	if test -z "$BASELIBS_CFG" -a -e $BUILD_ROOT/usr/lib/build/baselibs.conf ; then
	    BASELIBS_CFG="-c /usr/lib/build/baselibs.conf"
	fi
	chroot $BUILD_ROOT /usr/lib/build/mkbaselibs $BASELIBS_GLOBAL $BASELIBS_CFG $BPKGS || cleanup_and_exit 1
    else
	# use external version
	rm -rf $BUILD_ROOT/.mkbaselibs
	mkdir -p $BUILD_ROOT/.mkbaselibs
	cp -f $BUILD_DIR/mkbaselibs $BUILD_ROOT/.mkbaselibs/
	if test "$BUILDTYPE" == "dsc" ; then
	    cp -f $BUILD_DIR/baselibs_global-deb.conf $BUILD_ROOT/.mkbaselibs/baselibs_g.conf
	    cp -f $BUILD_ROOT$TOPDIR/SOURCES/baselibs-deb.conf $BUILD_ROOT/.mkbaselibs/baselibs-deb.conf
	    BASELIBS_CFG="-c /.mkbaselibs/baselibs-deb.conf"
	else
	    cp -f $BUILD_DIR/baselibs_global.conf $BUILD_ROOT/.mkbaselibs/baselibs_g.conf
	    if test -z "$BASELIBS_CFG" -a -e $BUILD_DIR/baselibs.conf; then
		cp -f $BUILD_DIR/baselibs.conf $BUILD_ROOT/.mkbaselibs/baselibs.conf
		BASELIBS_CFG="-c /.mkbaselibs/baselibs.conf"
	    fi
	fi
	if test -e $BUILD_ROOT/.mkbaselibs/baselibs_g.conf; then
	    BASELIBS_GLOBAL="-c /.mkbaselibs/baselibs_g.conf"
	fi
	chroot $BUILD_ROOT /.mkbaselibs/mkbaselibs $BASELIBS_GLOBAL $BASELIBS_CFG $BPKGS || cleanup_and_exit 1
	rm -rf $BUILD_ROOT/.mkbaselibs
    fi
}

# detect_vm_2nd_stage 函数的作用是探测是否需要进一步设置新的环境。如果
# 执行程序的路径名为 "/.build/build" ，说明已经在一个新的“环境”中，这时
# 候需要重新设置一些环境变量
# 这里好像不是检测是否在 chroot 环境，而是检测是否在 vm (虚拟机) 环境
# 因为 chroot 环境只有这些 (没有 /.build/build)：
# | -rwxr-xr-x  1 root root     112 09-17 02:08 .build.command
# | -rw-r--r--  1 root root      20 09-17 02:06 .buildenv
# | -rw-r--r--  1 root root   72598 09-17 02:08 .build.log
# | lrwxrwxrwx  1 root root    13 09-17 02:08 .build.packages -> usr/src/turbo

detect_vm_2nd_stage()
{
    # $0 就是程序名，注意 test 前的 ! 号。如果 $0 是 "/.build/build" ，
    # 说明当前已在一个虚拟环境中，跳过 "return 1"， 接着执行下面过程
    if ! test "$0" = "/.build/build" ; then
	return 1
    fi
    # 当检测到在一个虚拟机环境中时，这里主要重新准备一些变量
    echo "2nd stage started in virtual machine"
    BUILD_ROOT=/
    BUILD_DIR=/.build
    . $BUILD_DIR/build.data
    # uname -m 取得本机运行系统的架构：i386,x86_64,等
    #   -m, --machine            print the machine hardware name
    echo "machine type: `uname -m`"
    if test "$PERSONALITY" != 0 -a -z "$PERSONALITY_SET" ; then
	export PERSONALITY_SET=true
	echo "switching personality to $PERSONALITY..."
	# this is 32bit perl/glibc, thus the 32bit syscall number
        # 执行 system call 136, 
        # 136 是 personality 系统调用，改变系统的一些属性，可模拟其他系统环境
	exec perl -e 'syscall(136, '$PERSONALITY') == -1 && warn("personality: $!\n");exec "/.build/build" || die("/.build/build: $!\n")'
    fi
    PATH=$BUILD_DIR:$PATH
    RUNNING_IN_VM=true
    mount -orw -n -tproc none /proc
    mount -n -o remount,rw /
# qemu inside of xen does not work, check again with kvm later before enabling this
#    if [ -e /dev/kqemu ]; then
#        # allow abuild user to run qemu
#        chmod 0666 /dev/kqemu
#    fi
    # test -n : 测试变量是否为非空
    # shell 条件测试可参考：
    # http://jianlee.ylinux.org/Computer/Shell/shell_test.html
    if test -n "$VM_SWAP" ; then
        # for 循环等待 $VM_SWAP 目录可访问，最长等待10秒
	for i in 1 2 3 4 5 6 7 8 9 10 ; do
	    test -e "$VM_SWAP" && break
	    test $i = 1 && echo "waiting for $VM_SWAP to appear"
            # 默认 echo 换行，-n 参数让 echo 不输出换行符，效果是一秒输出一个点
	    echo -n .
	    sleep 1
	done
        # 作用是换行，如果 $i 是 1 ，那么没有输出过 "."，也就不需要换行符
	test $i = 1 || echo
	# recreate the swap device manually if it didn't exist for some
	# reason, hardcoded to hda2 atm
        # -b : 文件存在并且是块文件返回真
        # test -b "/dev/sda" && echo "True" || echo "False"
	if ! test -b "$VM_SWAP" ; then
            # 如果 $VM_SWAP 不是块文件，就删除之，再创建同名块文件
	    rm -f "$VM_SWAP"
            # umask 设置创建文件或目录要减去的值
            # 创建文件的默认权限： 666-$(umask)
            # 目录  ： 777-$(umask)
	    umask 027
	    mknod "$VM_SWAP" b 3 2
            # $VM_SWAP 权限为： brw-r----- 1 root root 3, 2 
	    umask 022
	fi
        # 无论如何到这里 $VM_SWAP 已经是块文件了
	swapon -v "$VM_SWAP" || exit 1
    fi
    HOST="$MYHOSTNAME"

    return 0
}

# find_spec_files 函数准备好 spec 文件，可以有多个
find_spec_files()
{
    # local 定义局部变量
    local spec files
    # -z 判断字符串是否为0
    if [ -z "$SPECFILES" ]; then
	set -- "`pwd`"
    else
	set -- "${SPECFILES[@]}"
    fi
    SPECFILES=()
    for spec in "$@"; do
        # ${spec#/} 去掉开头的 '/'，这里的作用是判断 $spec 路径是否是绝对路径
	if [ "$spec" = "${spec#/}" ]; then
	    spec="`pwd`/$spec"
	fi

	if [ -d "$spec" ]; then
            # specs 现在是包含 $spec/ 目录下所有 spec 文件，数组
	    specs=("$spec"/*.spec)
	    if [ -n "$specs" ]; then
		SPECFILES=("${SPECFILES[@]}" "${specs[@]}")
	    else
                # 下面这一段上面意思？重复？
		specs=("$spec"/*.spec)
		if [ -n "$specs" ]; then
		    SPECFILES=("${SPECFILES[@]}" "${specs[@]}")
		fi
	    fi
	else
            # 不是目录就是文件了
	    SPECFILES[${#SPECFILES[@]}]="$spec";
	fi
    done

    if test -z "$SPECFILES"; then
	echo no spec files or src rpms found in $@. exit...
	cleanup_and_exit 1
    fi
}

become_root_or_fail()
{
    if [ ! -w /root ]; then
	echo "You have to be root to use $0" >&2
	exit 1
    fi
    cleanup_and_exit 1
}

# 确保 build root 目录创建
mkdir_build_root()
{
    if [ -d "$BUILD_ROOT" ]; then
	# check if it is owned by root
        # "stat -c %u 目录" 得到目录的属主ID
        # "stat -c %U 目录" 属主名字
	if [ -z "$RUNNING_IN_VM" -a \! -O "$BUILD_ROOT" -a "`stat -c %u $BUILD_ROOT`" -ne 0 ]; then
	    echo "BUILD_ROOT=$BUILD_ROOT must be owned by $USER. Exit..."
	    cleanup_and_exit 1
	fi
    else
	test "$BUILD_ROOT" != "${BUILD_ROOT%/*}" && mkdir -p "${BUILD_ROOT%/*}"
	if ! mkdir $BUILD_ROOT; then
	    echo "can not create BUILD_ROOT=$BUILD_ROOT. Exit..."
	    cleanup_and_exit 1
	fi
    fi
    
    rm -rf "$BUILD_ROOT"/.build.packages
}

linux64()
{
	perl -e 'syscall('$PERSONALITY_SYSCALL', 0); exec(@ARGV) || die("$ARGV[0]: $!\n")' "$@"
}

#### main ####
# 除了脚本开始的一些变量设置，真正的开始从这里

# trap 命令捕捉 EXIT 信号，执行 fail_exit 代码
# trap 用法可参考 : 
# http://jianlee.ylinux.org/Computer/Shell/shell_builtin.html#sec1
trap fail_exit EXIT

# archname 类似如：
# archname='x86_64-linux-thread-multi';
case `perl -V:archname` in
    *x86_64*) PERSONALITY_SYSCALL=135 ;;
    *i?86*)   PERSONALITY_SYSCALL=136 ;;
esac

# shopt 设置 nullglob 属性，这样如果没有匹配到的文件名会用空串代替
# 请参考：http://jianlee.ylinux.org/Computer/Shell/shell_builtin.html#sec7
# | # echo libb*
# | libb*
# | # shopt -s nullglob
# | # echo libb*
shopt -s nullglob

# detect_vm_2nd_stage 是前面定义的一个函数
# 测试是否需要进一步设置环境
# set 命令直接接的字符串会设置为命令行各个参数( $1 $2 $3 ...)
# detect_vm_2nd_stage 函数返回 0 ，if 测试为 ture
if detect_vm_2nd_stage ; then
    set "/.build-srcdir/$SPECFILE"
    # 现在 echo $1 值为 "/.build-srcdir/$SPECFILE"
fi

# 目前 common_functions 定义了函数 set_build_arch ，这个函数设置了
# 标准的 $BUILD_ARCH
. $BUILD_DIR/common_functions || exit 1

export HOST

# $1 不为空，执行 while 处理命令行参数
while test -n "$1"; do
  # 除非$1形如 "--XXX=xxx",否则 ARG 会不变
  PARAM="$1"
  ARG="$2"
  # "shift n" : 一次把参数向左移动n个，丢弃前n个参数，即 $(n+1) 变成
  # $1。如果 n 为空，默认值是 1
  shift # 此处的 shift 和 下面第二个 case 处理中的 shift 刚好去掉 2 个参数
  # 下面的 case 把命令行参数中的 "--XXX=xxx" 变成 "----noarg=--XXX"，改
  # 变 PARAM 和 ARG 变量的值；如果此时 $PARAM 不是形如 "--XXX=xxx" ，就
  # 跳过下面case，PARAM 和 ARG 变量的值不变。
  case $PARAM in
    *-*=*)   # 注意，这里有个技巧 *- 可以匹配 -- ， 这样 --arch 和 -arch 都可以使用
      # "#*=" 表示去掉从开头到第一次找到'='的字符串
      ARG=${PARAM#*=}
      # 一个类似这样的参数 "--arch=i386"，此时ARG=i386，下面PARAM="--arch"
      PARAM=${PARAM%%=*}
      # -- 在命令后面，表示不让shell解释后面的字符串为选项
      # 如 "set -- --test1 test2 test3" ，如果不加 -- , shell 会报错
      # 这里增加一个 ---noarg 选项是为了后面好 shift ，因为
      # --rpms=XXX.rpm 类型的参数要加上一个“垃圾”选项，好满足本循环一次
      # 处理一个 “选项-参数” 对的处理方式
      set -- "----noarg=$PARAM" "$@"
  esac
  # 此时 ARG 保存着 PARAM 选项的参数
  case $PARAM in
      *-help|-h) # 输出帮助信息，退出
        echo_help
        cleanup_and_exit
      ;;
      *-no*init) # --noinit, --no-init, -no-init 等都可以匹配到
        DO_INIT=false
      ;;
      *-no*checks)
        DO_CHECKS=false
      ;;
      *-clean)
        CLEAN_BUILD='--clean'
      ;;
      *-kill)
        KILL=true
      ;;
      *-rpms)
        BUILD_RPMS="$ARG"
        # 如果给定 --rpms 选项，没有给参数，退出
	if [ -z "$BUILD_RPMS" ] ; then
	  echo_help
	  cleanup_and_exit
	fi
        shift
      ;;
      *-arch)
        # 不用检查$ARG是否为空，因为有默认 BUILD_ARCH
        BUILD_ARCH="$ARG"
        shift
      ;;
      *-verify)
        export VERIFY_BUILD_SYSTEM=true
      ;;
      *-target)
	ABUILD_TARGET_ARCH="$ARG"
	shift
      ;;
      *-jobs) 
	BUILD_JOBS="$ARG"
	shift
      ;;
      *-extra*packs|-X)
        BUILD_EXTRA_PACKS="$BUILD_EXTRA_PACKS $ARG"
        shift
      ;;
      *-lint)
        DO_LINT=true
        ;;
      *-baselibs)
        CREATE_BASELIBS=true
        ;;
      *-baselibs-internal)
        CREATE_BASELIBS=internal
        ;;
      *-root)
        BUILD_ROOT="$ARG"
        shift
      ;;
      *-oldpackages)
        OLD_PACKAGES="$ARG"
        shift
      ;;
      *-dist) 
	BUILD_DIST="$ARG"
	export BUILD_DIST
	shift
      ;;
      *-xen|*-kvm|--uml|--qemu)
	VM_TYPE=${PARAM##*-}
	if [ -n "$ARG" -a "$ARG" = "${ARG#-}" ]; then
	    VM_IMAGE="$ARG"
	    shift
	else
	    VM_IMAGE=1
	fi
      ;;
      *-xenswap|*-swap)
        VM_SWAP="$ARG"
        shift
      ;;
      *-xenmemory|*-memory)
        MEMSIZE="$ARG"
        shift
      ;;
      *-rpmlist)
        RPMLIST="--rpmlist $ARG"
	BUILD_RPMS=
        shift
      ;;
      *-release)
        RELEASE="$ARG"
        shift
      ;;
      *-logfile)
        LOGFILE="$ARG"
        shift
      ;;
      *-reason)
        REASON="$ARG"
        shift
      ;;
      *-norootforbuild)
        NOROOTFORBUILD=true
      ;;
      *-stage)
        BUILD_RPM_BUILD_STAGE="$ARG"
        shift
      ;;
      *-useusedforbuild)
        USEUSEDFORBUILD="--useusedforbuild"
      ;;
      *-list*state)
	LIST_STATE=true
      ;;
      --define|--with|--without)
        definesnstuff[${#definesnstuff[@]}]="$PARAM";
        definesnstuff[${#definesnstuff[@]}]="$ARG";
	shift
      ;;
      --repository|--repo)
        if [ -z "$ARG" ] ; then
          echo_help
          cleanup_and_exit
        fi
        # ${#repos[@]} 值为当前数组元素个数
        # 这里的作用是可以使用多个 --repository|--repo 选项指定多个 repos
        repos[${#repos[@]}]="$PARAM";
        repos[${#repos[@]}]="$ARG";
        shift
      ;;
      --icecream)
        if [ -z "$ARG" ] ; then
          echo "--icecream needs an argument" >&2
          echo_help
          cleanup_and_exit 1
        fi
        icecream="$ARG"
	if [ "$icecream" -gt 0 ]; then
		BUILD_JOBS="$ARG"
	fi
        shift
      ;;
      --ccache)
        ccache=1
      ;;
      --debug)
        BUILD_DEBUG=1
      ;;
      --incarnation)
        INCARNATION=$ARG
	shift
      ;;
      --disturl)
        DISTURL=$ARG
	shift
      ;;
      # 此处的技巧是先把 "[-]-XXX=xxx" 拆开，经过一轮分析到这里，如果
      # ----noarg 还在（如果处理就会shift掉），说明没有处理，则认为出错。
      ----noarg)
        echo "$ARG does not take an argument"
        cleanup_and_exit
      ;;
      *-changelog)
        CHANGELOG=true
      ;;
      --overlay)
        OVERLAY=$ARG
        shift
      ;;
      --rsync-src)
        RSYNCSRC=$ARG
        shift
      ;;
      --rsync-dest)
        RSYNCDEST=$ARG
        shift
      ;;
      # 这里对不能处理的选项
      -*)
        echo Unknown Option "$PARAM". Exit.
        cleanup_and_exit 1
      ;;
      # 处理完选项，就是build命令的参数了。
      *)
        SPECFILES[${#SPECFILES[@]}]="$PARAM";
      ;;
    esac
done
# 现在选项和参数处理完毕！

# XXX: doesn't kill vm if in prepare stage (because there is none)
# 此处处理 KILL
if test -n "$KILL" ; then
    test -z "$SRCDIR" || usage
    if test -z "$VM_IMAGE" ; then
	if ! $BUILD_DIR/killchroot -s 9 $BUILD_ROOT ; then
	    echo "could not kill build in $BUILD_ROOT"
	    cleanup_and_exit 1
	fi
    elif test "$VM_TYPE" = 'xen'; then
	XENID="${VM_IMAGE%/root}"
	XENID="${XENID##*/}"
	if xm list "build:$XENID" >/dev/null 2>&1 ; then
	    if ! xm destroy "build:$XENID" ; then
		echo "could not kill xen build $XENID"
		cleanup_and_exit 1
	    fi
	fi
    elif test -n "$VM_TYPE"; then
	if ! fuser -k -TERM "$VM_IMAGE"; then
	    echo "could not kill build in $VM_IMAGE"
	    cleanup_and_exit 1
	fi
    else
	echo "don't know how to kill this build job"
	cleanup_and_exit 1
    fi
    cleanup_and_exit 0
fi

# 使用 KVM 虚拟机，可先跳过(通常使用chroot)
if [ "$VM_TYPE" = 'kvm' ]; then
    # -r 指定的文件或目录存在并且可读时返回真
    # -x 指定的文件或目录存在并且可执行时返回真
    # -o 是将左右两个条件测试结果做或运算（一个为真即为真）
    if [ ! -r /dev/kvm -o ! -x "$qemu_bin"-kvm ]; then
	echo ""
    fi
    qemu_bin="$kvm_bin"
    qemu_kernel="$kvm_kernel"
    qemu_initrd="$kvm_initrd"
    # -e 指定的文件或目录存在时返回真
    # -nt "f1 -nt f2" 表示  file f1 is newer than f2
    if [ ! -e $qemu_initrd-virtio -o $qemu_kernel -nt $qemu_initrd-virtio ]; then
	if [ ! -w /root ]; then
	    echo "No initrd that provides virtio support found. virtio accelleration disabled."
	    echo "Run the following command as root to enable virtio:"
	    shellquote "${mkinitrd_virtio_cmd[@]}"
	    echo
        # ">/dev/null" 把本应该输出到屏幕(stdout)的内容输出到
        # /dev/null(有去无回的地方）；"2>&1" 把stderr(也是屏幕)的信息导
        # 入到和stdout同一个地方（/dev/null）
	elif /sbin/modinfo virtio_pci >/dev/null 2>&1; then
	    echo "creating $qemu_initrd-virtio"
	    "${mkinitrd_virtio_cmd[@]}" || cleanup_and_exit 1
	    kvm_virtio=1
	fi
    else
	kvm_virtio=1
    fi

    if [ "$kvm_virtio" = 1 ]; then
	qemu_initrd="$qemu_initrd-virtio"
	VM_SWAPDEV=/dev/vdb
	qemu_rootdev=/dev/vda
    else
	VM_SWAPDEV=/dev/sdb
	qemu_rootdev=/dev/sda
    fi
fi

if [ "$VM_TYPE" = 'qemu' ]; then
    VM_SWAPDEV=/dev/sdb
    qemu_rootdev=/dev/sda
fi

# 如果命令行使用 "--rpmlist" 指定一个 rpmlist 文件，就执行 if
# -z 字符串为空串(长度为0)时返回真
if [ -z "$RPMLIST" ]; then
    if [ -z "$repos" -a -z "$BUILD_RPMS" ]; then
	BUILD_RPMS="/media/dvd/suse"
    fi
else
    repos=()
fi

# common_functions 文件中定义的函数，设置 BUILD_ARCH
set_build_arch

if [ -n "$CLEAN_BUILD" ]; then
    DO_INIT=true
fi

# find_spec_files 准备好 spec 文件，可以有多个，存在 SPECFILES 数组变量中
find_spec_files

# LIST_STATE 由  "*-list*state" 命令行参数控制为 true 或空
if test -n "$LIST_STATE" ; then
    # mktemp 函数创建动态命名的目录，并返回创建的目录
    BUILD_ROOT=`mktemp -d /var/tmp/build-list-state-XXXXXX`
    test -d "$BUILD_ROOT" || cleanup_and_exit 3
    # SPECFILES 是数组变量，但是 $SPECFILES 显示第一个变量
    SPECFILE=$SPECFILES # only one specified anyways
    # 测试 SPECFILES 是不是 *.src.rpm 包
    if test "$SPECFILE" != "${SPECFILE%.src.rpm}" ; then
       # 到这里，说明 SPECFILE 是 *.src.rpm 包
       rm -rf $BUILD_ROOT/usr/src/packages
       mkdir -p $BUILD_ROOT/usr/src/packages/SOURCES $BUILD_ROOT/usr/src/packages/SPECS
       rpm -i --nodigest --nosignature --root $BUILD_ROOT $SPECFILE || {
	   echo "could not install $SPECFILE." 2>&1
	   rm -rf $BUILD_ROOT
	   cleanup_and_exit 3
       }
       # for 循环没有执行具体命令，但是 SPECFILE 可能变了
       for SPECFILE in $BUILD_ROOT/usr/src/packages/SPECS/*.spec ; do : ; done
    fi
    init_buildsystem --list-state "${definesnstuff[@]}" "${repos[@]}" $USEUSEDFORBUILD $SPECFILE $BUILD_EXTRA_PACKS
    ERR=$?
    rm -rf $BUILD_ROOT
    cleanup_and_exit $ERR
fi

if test -z "$RUNNING_IN_VM" ; then
    if test -n "$VM_IMAGE" ; then
	if test "$VM_IMAGE" = 1 ; then
	    VM_IMAGE="$BUILD_ROOT.img"
	fi
	if test ! -e "$VM_IMAGE" ; then
	    echo "you need to create a file system on $VM_IMAGE first"
	    cleanup_and_exit 3
	fi
    fi
    if test -n "$VM_IMAGE" ; then
	if test -n "$CLEAN_BUILD" ; then
	    echo "Creating filesystem on $VM_IMAGE"
	    $vm_img_mkfs $VM_IMAGE || cleanup_and_exit 3
	    if test -n "$vm_img_tunefs" ; then
 $vm_img_tunefs $VM_IMAGE || cleanup_and_exit 3
	    fi
	fi
	mkdir_build_root
	if [ -w /root ]; then
	    mount -o loop $VM_IMAGE $BUILD_ROOT || cleanup_and_exit 3
	else
	    mount $BUILD_ROOT || cleanup_and_exit 3
	fi
    else
	test -w /root || become_root_or_fail
    fi
    if test -n "$VM_SWAP" ; then
	dd if=/dev/zero of="$VM_SWAP" bs=12 count=1 conv=notrunc 2>/dev/null
	mkswap "$VM_SWAP"
    fi
fi

mkdir_build_root

rm -f $BUILD_ROOT/exit

# 我想测试 /root 是否可写就是查看用户是否有root权限
if [ -w /root ]; then
    # 创建 proc 和 dev/pts 目录，并挂载host系统资源
    # 请看 http://jianlee.ylinux.org/Computer/Linux发行版开发/chroot-predo.html
    mkdir -p $BUILD_ROOT/proc
    mkdir -p $BUILD_ROOT/dev/pts
    mount -n -tproc none $BUILD_ROOT/proc || true
    mount -n -tdevpts none $BUILD_ROOT/dev/pts
fi

if test -z "$VM_IMAGE" -a -z "$LOGFILE"; then
    LOGFILE="$BUILD_ROOT/.build.log"
fi

# 如果设置了 $LOGFILE 变量，下面的动作让标准输出和标准错误输出通过 tee
# 管道通向 $LOGFILE 文件和 stdout 各一份。
if test -n "$LOGFILE" ; then
    echo  logging output to $LOGFILE...
    rm -f $LOGFILE
    touch $LOGFILE
    if test -n "$VM_IMAGE" ; then
	exec 1> >(exec -a 'build logging tee' perl -e 'open(F,">>",$ARGV[0])||die("$ARGV[0]: $!\n");$|=1;select(F);$|=1;while(<STDIN>){print STDOUT;s/^\r//s;s/\r\n/\n/gs;print F}' $LOGFILE) 2>&1
    else
	exec 1> >(exec -a 'build logging tee' tee -a $LOGFILE) 2>&1
    fi
fi

# 设置虚拟内存限额
setmemorylimit

#
# say hello
#
test -z "$HOST" && HOST=`hostname`

if [ -z "$RUNNING_IN_VM" ]; then
    echo Using BUILD_ROOT=$BUILD_ROOT
    test -n "$BUILD_RPMS" && echo Using BUILD_RPMS=$BUILD_RPMS
    echo Using BUILD_ARCH=$BUILD_ARCH
    test -n "$VM_TYPE" && echo "Doing $VM_TYPE build in $VM_IMAGE"
    echo
fi

test "$BUILD_ARCH" = all && BUILD_ARCH=
BUILD_USER_ABUILD_USED=

# 一个很长 (800 多行）的 for 循环，分别编译命令行提供的多个编译包
for SPECFILE in "${SPECFILES[@]}" ; do

    SRCDIR="${SPECFILE%/*}"
    SPECFILE="${SPECFILE##*/}"

    BUILDTYPE=
    case $SPECFILE in
      *.spec|*.src.rpm) BUILDTYPE=spec ;;
      *.dsc) BUILDTYPE=dsc ;;
      *.kiwi) BUILDTYPE=kiwi ;;
    esac
    if test -z "$BUILDTYPE" ; then
       echo "don't know how to build $SPECFILE"
       cleanup_and_exit 1
    fi

    cd "$SRCDIR"

    if [ -z "$RUNNING_IN_VM" ]; then
	echo
	echo "$HOST started \"build $SPECFILE\" at `date`."
	echo
	test -n "$REASON" && echo "$REASON"
	echo
    fi

    #
    # first setup building directory...
    #
    # -s 测试文件存在并且大小大于0
    test -s "$SPECFILE" || {
       echo "$SPECFILE" is empty.  This should not happen...
       cleanup_and_exit 1
    }

    # 测试 $SPECFILE 是否为 *.src.rpm 包
    if test "$SPECFILE" != "${SPECFILE%.src.rpm}" ; then
	echo processing src rpm $SRCDIR/$SPECFILE ...
	MYSRCDIR=$BUILD_ROOT/.build-srcdir
	rm -rf $MYSRCDIR
	mkdir -p $MYSRCDIR
	cd $MYSRCDIR || cleanup_and_exit 1
        # unrpm 是 YBuild 自带的一个脚本，利用 rpm2cpio 解压 rpm 包
	$BUILD_DIR/unrpm -q $SRCDIR/$SPECFILE || {	    
	    echo "could not install $SPECFILE."
	    cleanup_and_exit 1
	}
        # 下面 for 循环的目的只是让 SPECFILE 等于 *.spec 文件，此目录下
        # 只有一个 *.spec 文件。
	for SPECFILE in *.spec ; do : ; done
    else
	MYSRCDIR="$SRCDIR"
        # strip prefix from autogenerated files from OBS.
        for i in $MYSRCDIR/_service\:*; do
          mv "$i" "${i##*:}"
        done
        SPECFILE="${SPECFILE##*:}"
    fi

    # FIX to work with baselibs_$PROJ etc
    if test "$BUILDTYPE" == "dsc" -a -e ${SRCDIR}/baselibs-deb.conf ; then
	# Set CREATE_BASELIBS if not set
	echo "dsc build and baselibs-deb.conf present: forcing --baselibs to true"
	CREATE_BASELIBS=true
    fi

# Currently local osc build does not allow extra .deb packages to be
# specified on the command line. Both init_buildsystem and expanddeps
# need to handle .deb dependencies first
#    if test -n "$CREATE_BASELIBS" ; then
#	case $BUILDTYPE in
#	    spec) ;;
#	    dsc) BUILD_EXTRA_PACKS="$BUILD_EXTRA_PACKS libparse-debcontrol-perl" ;;
#	esac
#    fi

    echo processing specfile $MYSRCDIR/$SPECFILE ...

    ADDITIONAL_PACKS=""
    test -n "$BUILD_EXTRA_PACKS" && ADDITIONAL_PACKS="$ADDITIONAL_PACKS $BUILD_EXTRA_PACKS"
    test -n "$CREATE_BASELIBS" && ADDITIONAL_PACKS="$ADDITIONAL_PACKS build"
    test "$ccache" = '1' && ADDITIONAL_PACKS="$ADDITIONAL_PACKS ccache"
    test "$icecream" -gt 1 && ADDITIONAL_PACKS="$ADDITIONAL_PACKS icecream gcc-c++"
    test -n "$DO_LINT" && ADDITIONAL_PACKS="$ADDITIONAL_PACKS rpmlint-Factory"

    if test -n "$CHANGELOG" -a -z "$RUNNING_IN_VM" ; then
	rm -f $BUILD_ROOT/.build-changelog
	case $SPECFILE in
	  *.dsc) CFFORMAT=debian ;;
	  *) CFFORMAT=rpm ;;
	esac
	echo "running changelog2spec --target $CFFORMAT --file $MYSRCDIR/$SPECFILE"
        # changelog2spec 是一个 perl 脚本
        # Convert a SUSE or Debian changelog file to rpm format
	if ! $BUILD_DIR/changelog2spec --target $CFFORMAT --file "$MYSRCDIR/$SPECFILE" > $BUILD_ROOT/.build-changelog ; then
	    rm -f $BUILD_ROOT/.build-changelog
	fi
    fi

    # 在 VM 中时
    if test -n "$VM_TYPE"; then
	rm -rf $BUILD_ROOT/.build
	mkdir -p $BUILD_ROOT/.build
	if test "$DO_INIT" = true ; then
	    # do fist stage of init_buildsystem
	    rm -f $BUILD_ROOT/.build.success
	    set -- init_buildsystem --prepare "${definesnstuff[@]}" "${repos[@]}" $CLEAN_BUILD $USEUSEDFORBUILD $RPMLIST "$MYSRCDIR/$SPECFILE" $ADDITIONAL_PACKS
	    echo "$* ..."
	    "$@" || cleanup_and_exit 1
	    if [ ! -w /root ]; then
		# remove setuid bit if files belong to user to make e.g. mount work
		find $BUILD_ROOT/{bin,sbin,usr/bin,usr/sbin} -type f -uid $UID -perm +4000 -print0 | xargs -0 --no-run-if-empty chmod -s
	    fi
            if [ -d "$OLD_PACKAGES" ]; then
               rm -rf $BUILD_ROOT/.build.oldpackages
               cp -a $OLD_PACKAGES $BUILD_ROOT/.build.oldpackages
            fi
	fi
	# start up xen, rerun ourself
	cp -a $BUILD_DIR/. $BUILD_ROOT/.build
	if ! test "$MYSRCDIR" = $BUILD_ROOT/.build-srcdir ; then
	    rm -rf $BUILD_ROOT/.build-srcdir
	    mkdir $BUILD_ROOT/.build-srcdir
	    if test "$BUILDTYPE" = kiwi ; then
		cp -pRL "$MYSRCDIR"/* $BUILD_ROOT/.build-srcdir
	    else
		cp -p "$MYSRCDIR"/* $BUILD_ROOT/.build-srcdir
	    fi
	    MYSRCDIR=$BUILD_ROOT/.build-srcdir
	else
	    # cwd is at $BUILD_ROOT/.build-srcdir which we want to
	    # umount later so step aside
	    cd "$SRCDIR"
	fi
	Q="'\''"
	echo "SPECFILE='${SPECFILE//"'"/$Q}'" > $BUILD_ROOT/.build/build.data
	echo "BUILD_JOBS='${BUILD_JOBS//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "BUILD_ARCH='${BUILD_ARCH//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "BUILD_RPMS='${BUILD_RPMS//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	case $BUILD_DIST in
	    */*)
		cp $BUILD_DIST $BUILD_ROOT/.build/build.dist
		BUILD_DIST=/.build/build.dist
		;;
	esac
	echo "BUILD_DIST='${BUILD_DIST//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "RELEASE='${RELEASE//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "BUILD_DEBUG='${BUILD_DEBUG//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "DO_LINT='${DO_LINT//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "DO_CHECKS='${DO_CHECKS//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "NOROOTFORBUILD='${NOROOTFORBUILD//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "CREATE_BASELIBS='$CREATE_BASELIBS'" >> $BUILD_ROOT/.build/build.data
	echo "REASON='${REASON//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "CHANGELOG='${CHANGELOG//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "INCARNATION='${INCARNATION//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	echo "DISTURL='${DISTURL//"'"/$Q}'" >> $BUILD_ROOT/.build/build.data
	# FIXME: this depends on the kernel and vm.
	# could be hda2, sda2 for xen or hdb/sdb for qemu
	test -n "$VM_SWAP" && echo "VM_SWAP='${VM_SWAPDEV:-/dev/hda2}'" >> $BUILD_ROOT/.build/build.data
	PERSONALITY=0
	test -n "$PERSONALITY_SYSCALL" && PERSONALITY=`perl -e 'print syscall('$PERSONALITY_SYSCALL', 0)."\n"'`
	echo "OLD_PACKAGES='$OLD_PACKAGES'" >> $BUILD_ROOT/.build/build.data
	echo "PERSONALITY='$PERSONALITY'" >> $BUILD_ROOT/.build/build.data
	echo "MYHOSTNAME='`hostname`'" >> $BUILD_ROOT/.build/build.data
	echo -n "definesnstuff=(" >> $BUILD_ROOT/.build/build.data
	shellquote "${definesnstuff[@]}" >> $BUILD_ROOT/.build/build.data
	echo ")" >> $BUILD_ROOT/.build/build.data
	echo -n "repos=(" >> $BUILD_ROOT/.build/build.data
	shellquote "${repos[@]}" >> $BUILD_ROOT/.build/build.data
	echo ")" >> $BUILD_ROOT/.build/build.data
	umount -n $BUILD_ROOT/proc 2> /dev/null || true
	umount -n $BUILD_ROOT/dev/pts 2> /dev/null || true
	umount -n $BUILD_ROOT/mnt 2> /dev/null || true

	# needs to work otherwise we have a corrupted file system
	umount $BUILD_ROOT || cleanup_and_exit 1

	if [ "$VM_TYPE" = 'xen' ]; then
		XMROOT=file:$VM_IMAGE
		XMROOT=${XMROOT/#file:\/dev/phy:/dev}
		XMROOT="disk=$XMROOT,hda1,w"
		XMSWAP=
		if test -n "$VM_SWAP" ; then
		    XMSWAP=file:$VM_SWAP
		    XMSWAP=${XMSWAP/#file:\/dev/phy:/dev}
		    XMSWAP="disk=$XMSWAP,hda2,w"
		fi
		XENID="${VM_IMAGE%/root}"
		XENID="${XENID##*/}"
		CROSS_INIT_SCRIPT="/.build/build"
		# to run the qemu initialization in the XEN chroot, we need to register it with a statically build shell
		if [ x"$BUILD_ARCH" == xarmv4l -o x"$BUILD_ARCH" == xarmv5el -o x"$BUILD_ARCH" == xarmv7el -o x"$BUILD_ARCH" == xsh4 -o x"$BUILD_ARCH" == xppc ]; then
		    if [  -n "$(uname -m | grep '[x3-6]86')" ]; then
			if [ -e /bin/bash-static -a -e /bin/mount-static ]; then
			    CROSS_INIT_SCRIPT="/.build/initscript_qemu_vm"
			fi
		    fi
		fi

		echo "booting XEN kernel ..."
                if xm list "build:$XENID" >/dev/null 2>&1 ; then
                   echo "Instance already exist, something really went wrong..."
                   echo "Please report to your server admin, there might be multiple services running for same domain"
                   cleanup_and_exit 3
                fi
		set -- xm create -c $BUILD_DIR/xen.conf name="build:$XENID" ${MEMSIZE:+memory=$MEMSIZE} $XMROOT $XMSWAP extra="quiet init="$CROSS_INIT_SCRIPT" panic=1 console=ttyS0"
		if test "$PERSONALITY" != 0 ; then
		    # have to switch back to PER_LINUX to make xm work
		    set -- linux64 "$@"
		fi
		echo "$@"
		"$@" || cleanup_and_exit 3
	elif [ "$VM_TYPE" = 'uml' ]; then
		echo "booting UML kernel ..."
		set -- $uml_kernel initrd=$uml_initrd root=/ubda init=/.build/build panic=1 quiet ubd0=$VM_IMAGE ${MEMSIZE:+mem=$MEMSIZE}
		echo "$@"
		"$@"
	elif [ "$VM_TYPE" = 'qemu' -o "$VM_TYPE" = 'kvm' ]; then
		echo "booting $VM_TYPE ..."
		if [ "$kvm_virtio" = 1 ]; then
		    qemu_disks=(-drive file="$VM_IMAGE",if=virtio -hda "$VM_IMAGE")
		    if [ -n "$VM_SWAP" ]; then
			qemu_disks[${#qemu_disks[@]}]="-drive"
			qemu_disks[${#qemu_disks[@]}]="file=$VM_SWAP,if=virtio"
		    fi
		else
		    qemu_disks=(-hda "$VM_IMAGE")
		    if [ -n "$VM_SWAP" ]; then
			qemu_disks[${#qemu_disks[@]}]="-hdb"
			qemu_disks[${#qemu_disks[@]}]="$VM_SWAP"
		    fi
		fi
		set -- $qemu_bin -no-reboot -nographic -net none -serial stdio \
		    -kernel $qemu_kernel \
		    -initrd $qemu_initrd \
		    -append "root=$qemu_rootdev panic=1 quiet noapic rw console=ttyS0 init=/.build/build" \
		    ${MEMSIZE:+-m $MEMSIZE} \
		    "${qemu_disks[@]}"

		if test "$PERSONALITY" != 0 ; then
		    # have to switch back to PER_LINUX to make qemu work
		    set -- linux64 "$@"
		fi
		echo "$@"
		"$@"
	fi
	if test -n "$VM_SWAP" ; then
	    BUILDSTATUS=`dd if="$VM_SWAP" bs=12 count=1 2>/dev/null`
	    case $BUILDSTATUS in
	      BUILDSTATUS[02])
		mkdir -p $BUILD_ROOT/.build.packages 
		cd $BUILD_ROOT/.build.packages || cleanup_and_exit 1
		echo "build: extracting built packages..."
		extractbuild --disk "$VM_IMAGE" --input "$VM_SWAP" --skip 512 -v || cleanup_and_exit 3
                # create same layout as with plain chroot
                if test "$BUILDTYPE" = spec ; then
                  mkdir -p SRPMS
                  for i in *src.rpm; do mv "$i" SRPMS/; done
                  for i in *.rpm; do
                    arch=${i%.rpm}
                    arch=${arch##*\.}
                    mkdir -p RPMS/$arch
                    mv "$i" RPMS/$arch/;
                  done
                elif test "$BUILDTYPE" = dsc ; then
                  mkdir -p DEBS
                  find . -type f | while read i; do mv "$i" DEBS/; done
                else
                  mkdir -p KIWI
                  find . -type f | while read i; do mv "$i" KIWI/; done
                fi
		cleanup_and_exit ${BUILDSTATUS#BUILDSTATUS}
		;;
	      *)
		cleanup_and_exit ${BUILDSTATUS#BUILDSTATUS}
		;;
	    esac
	    cleanup_and_exit 1
	fi
	cleanup_and_exit 0
    fi

    # 如果设置了 DO_INIT 变量，就做以下初始化工作
    if test "$DO_INIT" = true ; then
	#
	# create legacy .buildenv file
	#
	test -z "$INCARNATION" && INCARNATION=0
	echo "BUILD_INCARNATION=$INCARNATION" > $BUILD_ROOT/.buildenv
	CREATE_BUILD_BINARIES=
	egrep '^#[       ]*needsbinariesforbuild[       ]*$' >/dev/null <$MYSRCDIR/$SPECFILE && CREATE_BUILD_BINARIES=--create-build-binaries
        set -- init_buildsystem "${definesnstuff[@]}" "${repos[@]}" $CLEAN_BUILD $USEUSEDFORBUILD $CREATE_BUILD_BINARIES $RPMLIST "$MYSRCDIR/$SPECFILE" $ADDITIONAL_PACKS
	echo "$* ..."
	"$@" || cleanup_and_exit 1
	if df $BUILD_ROOT 2>/dev/null | grep -q "100%"; then
	    df -h $BUILD_ROOT
	    echo "build does not work on a completely full filesystem"
	    cleanup_and_exit 1
	fi
	mount -n -tproc none $BUILD_ROOT/proc || true
	mount -n -tdevpts none $BUILD_ROOT/dev/pts
        if [ -d "$OLD_PACKAGES" ]; then
           [ -d "$BUILD_ROOT/.build.oldpackages" ] || cp -r $OLD_PACKAGES $BUILD_ROOT/.build.oldpackages
        fi
    fi

    if test -z "$BUILD_DIST" -a -e "$BUILD_ROOT/.guessed_dist" ; then
	BUILD_DIST=`cat $BUILD_ROOT/.guessed_dist`
	echo "assuming dist $BUILD_DIST"
    fi

    #
    # fix rpmrc if we are compiling for i686
    #
    test -f $BUILD_ROOT/usr/lib/rpm/rpmrc_i586 && mv $BUILD_ROOT/usr/lib/rpm/rpmrc_i586 $BUILD_ROOT/usr/lib/rpm/rpmrc
    if test -e $BUILD_ROOT/usr/lib/rpm/rpmrc -a "$BUILD_ARCH" != "${BUILD_ARCH#i686}" ; then
	mv $BUILD_ROOT/usr/lib/rpm/rpmrc $BUILD_ROOT/usr/lib/rpm/rpmrc_i586
	sed -e 's/^buildarchtranslate: athlon.*/buildarchtranslate: athlon: i686/' -e 's/^buildarchtranslate: i686.*/buildarchtranslate: i686: i686/' < $BUILD_ROOT/usr/lib/rpm/rpmrc_i586 > $BUILD_ROOT/usr/lib/rpm/rpmrc
    fi

    #
    # check if we want to build with the abuild user
    #
    BUILD_USER=abuild
    if test -x $BUILD_ROOT/bin/rpm ; then
	SUSE_VERSION=`chroot $BUILD_ROOT /bin/rpm --eval '%{?suse_version}' 2>/dev/null`
	if test -n "$SUSE_VERSION" && test "$SUSE_VERSION" -le 1020 ; then
	    BUILD_USER=root
	fi
    fi
    if test "$BUILD_USER" = abuild ; then
	egrep '^#[       ]*needsrootforbuild[       ]*$' >/dev/null <$SPECFILE && BUILD_USER=root
    else
	egrep '^#[       ]*norootforbuild[       ]*$' >/dev/null <$SPECFILE && BUILD_USER=abuild
    fi
    test -n "$NOROOTFORBUILD" && BUILD_USER=abuild
    test "$BUILDTYPE" = kiwi && BUILD_USER=root

    # 如果使用 abuild 用户，而系统目前还没有此用户，就创建一个
    if test $BUILD_USER = abuild ; then
        if ! egrep '^abuild:' >/dev/null <$BUILD_ROOT/etc/passwd ; then
            echo 'abuild::399:399:Autobuild:/home/abuild:/bin/bash' >>$BUILD_ROOT/etc/passwd
            echo 'abuild:*:::::::' >>$BUILD_ROOT/etc/shadow # This is needed on Mandriva 2009
            echo 'abuild:*:::::::' >>$BUILD_ROOT/etc/gshadow # This is needed on Ubuntu 8.10
            echo 'abuild::399:' >>$BUILD_ROOT/etc/group
            mkdir -p $BUILD_ROOT/home/abuild
            chown 399:399 $BUILD_ROOT/home/abuild
        fi
	if test -f $BUILD_ROOT/etc/shadow ; then
	    sed -e "s@^root::@root:*:@" < $BUILD_ROOT/etc/shadow > $BUILD_ROOT/etc/shadow.t && mv $BUILD_ROOT/etc/shadow.t $BUILD_ROOT/etc/shadow
	fi
	if test -f $BUILD_ROOT/etc/gshadow ; then
	    sed -e "s@^root::@root:*:@" < $BUILD_ROOT/etc/gshadow > $BUILD_ROOT/etc/gshadow.t && mv $BUILD_ROOT/etc/gshadow.t $BUILD_ROOT/etc/gshadow
	fi
	BUILD_USER_ABUILD_USED=true
    else
        if egrep '^abuild:' >/dev/null <$BUILD_ROOT/etc/passwd ; then
            rm -rf $BUILD_ROOT/home/abuild
            egrep -v '^abuild:' <$BUILD_ROOT/etc/passwd >$BUILD_ROOT/etc/passwd.new
            mv $BUILD_ROOT/etc/passwd.new $BUILD_ROOT/etc/passwd
            egrep -v '^abuild:' <$BUILD_ROOT/etc/group >$BUILD_ROOT/etc/group.new
            mv $BUILD_ROOT/etc/group.new $BUILD_ROOT/etc/group
            if test -f $BUILD_ROOT/etc/shadow ; then
              egrep -v '^abuild:' <$BUILD_ROOT/etc/shadow >$BUILD_ROOT/etc/shadow.new
              mv $BUILD_ROOT/etc/shadow.new $BUILD_ROOT/etc/shadow
            fi
            if test -f $BUILD_ROOT/etc/gshadow ; then
              egrep -v '^abuild:' <$BUILD_ROOT/etc/gshadow >$BUILD_ROOT/etc/gshadow.new
              mv $BUILD_ROOT/etc/gshadow.new $BUILD_ROOT/etc/gshadow
            fi
        fi
    fi

    if test "$BUILDTYPE" = spec ; then
	TOPDIR=`chroot $BUILD_ROOT su -c "rpm --eval '%_topdir'" - $BUILD_USER`
    else
	TOPDIR=/usr/src/packages
	mkdir -p $BUILD_ROOT$TOPDIR
    fi

    rm -f $BUILD_ROOT/.build.packages
    ln -s ${TOPDIR#/} $BUILD_ROOT/.build.packages

    mount -n -tproc none $BUILD_ROOT/proc 2> /dev/null
    mount -n -tdevpts none $BUILD_ROOT/dev/pts 2> /dev/null
 
    setupicecream # 设置分布式编译 icecream

    setupccache # 设置 ccache，另外一个加速 c/c++ 编译速度的软件

    # nasty hack to prevent rpath on known paths
    # FIXME: do this only for suse
    if test -d "$BUILD_ROOT/etc/profile.d" ; then
	echo "export SUSE_IGNORED_RPATHS=/etc/ld.so.conf" > "$BUILD_ROOT/etc/profile.d/buildsystem.sh"
    fi

    #
    # now clean up RPM building directories
    #
    rm -rf $BUILD_ROOT$TOPDIR
    for i in BUILD RPMS/`uname -m` RPMS/i386 RPMS/noarch SOURCES SPECS SRPMS BUILDROOT; do
        mkdir -p $BUILD_ROOT$TOPDIR/$i
	test $BUILD_USER = abuild && chown 399:399 $BUILD_ROOT$TOPDIR/$i
    done
    test -e $BUILD_ROOT/exit && cleanup_and_exit

    # 清理完，在创建 SOURCES 目录，拷贝 SOURCES
    mkdir -p $BUILD_ROOT$TOPDIR/SOURCES
    if test "$BUILDTYPE" = kiwi ; then
	mkdir -p $BUILD_ROOT$TOPDIR/KIWI
	if test "$MYSRCDIR" = $BUILD_ROOT/.build-srcdir ; then
	    mv "$MYSRCDIR"/* $BUILD_ROOT$TOPDIR/SOURCES/
	else
	    cp -dLR "$MYSRCDIR"/* $BUILD_ROOT$TOPDIR/SOURCES/
	fi
    else
	cp -p "$MYSRCDIR"/* $BUILD_ROOT$TOPDIR/SOURCES/
    fi
    test "$MYSRCDIR" = $BUILD_ROOT/.build-srcdir && rm -rf "$MYSRCDIR"
    CHANGELOGARGS=
    test -n "$CHANGELOG" -a -f "$BUILD_ROOT/.build-changelog" && CHANGELOGARGS="--changelog $BUILD_ROOT/.build-changelog"

    # 编译 spec 类型
    if test "$BUILDTYPE" = spec ; then
	# do buildrequires/release substitution
	args=()
	if test -n "$RELEASE"; then
		args=(--release "$RELEASE")
	fi
        # substitutedeps 是一个 perl 脚本
	substitutedeps "${args[@]}" --dist "$BUILD_DIST" --archpath "$BUILD_ARCH" --configdir "$BUILD_DIR/configs" $CHANGELOGARGS "$BUILD_ROOT$TOPDIR/SOURCES/$SPECFILE" "$BUILD_ROOT/.spec.new" || cleanup_and_exit 1
	# extract macros from configuration
        # getmacros 是一个 perl 脚本
	getmacros --dist "$BUILD_DIST" --archpath "$BUILD_ARCH" --configdir "$BUILD_DIR/configs" > $BUILD_ROOT/root/.rpmmacros
	if test -n "$BUILD_DEBUG" ; then
	    echo '
%prep %?_suse_insert_debug_package%%prep
%package %?_suse_insert_debug_package%%package
%suse_insert_debug_package \
  %global _suse_insert_debug_package \\\
    %%undefine _suse_insert_debug_package \\\
    %%debug_package

' >> $BUILD_ROOT/root/.rpmmacros
	fi
	test $BUILD_USER = abuild && cp -p $BUILD_ROOT/root/.rpmmacros $BUILD_ROOT/home/abuild/.rpmmacros
	# extract optflags from configuration
        # getoptflags 是一个 perl 脚本
	getoptflags --dist "$BUILD_DIST" --configdir "$BUILD_DIR/configs" --archpath "$BUILD_ARCH" ${BUILD_DEBUG:+--debug} > $BUILD_ROOT/root/.rpmrc
	test $BUILD_USER = abuild && cp -p $BUILD_ROOT/root/.rpmrc $BUILD_ROOT/home/abuild/.rpmrc
	# case arm, extract changetarget
	# this is restricted to arm to make sure it doesn't interfere with x86
	buildarchtest=$( echo $BUILD_ARCH | grep -i arm )
	if [ x"$buildarchtest" != x"" ]; then
	    echo "changing targetarch" 
	    CHANGETARGET=$(getchangetarget --dist "$BUILD_DIST" --configdir "$BUILD_DIR/configs" --archpath "$BUILD_ARCH" )
	    echo "NEW TARGET: $CHANGETARGET"
	fi
    fi
    if test -f $BUILD_ROOT/.spec.new ; then
	if ! cmp -s $BUILD_ROOT$TOPDIR/SOURCES/$SPECFILE $BUILD_ROOT/.spec.new ; then
	    echo -----------------------------------------------------------------
	    echo I have the following modifications for $SPECFILE:
	    sed -e "/^%changelog/q" $BUILD_ROOT$TOPDIR/SOURCES/$SPECFILE > $BUILD_ROOT/.spec.t1
	    sed -e "/^%changelog/q" $BUILD_ROOT/.spec.new > $BUILD_ROOT/.spec.t2
	    diff $BUILD_ROOT/.spec.t1 $BUILD_ROOT/.spec.t2
	    rm -f $BUILD_ROOT/.spec.t1 $BUILD_ROOT/.spec.t2
	    mv $BUILD_ROOT/.spec.new $BUILD_ROOT$TOPDIR/SOURCES/$SPECFILE
	else
	    rm -f $BUILD_ROOT/.spec.new
	fi
    fi

    # debian 编译类型
    if test "$BUILDTYPE" = dsc ; then
	rm -rf $BUILD_ROOT$TOPDIR/BUILD
	mkdir -p $BUILD_ROOT$TOPDIR/SOURCES.DEB
	test $BUILD_USER = abuild && chown 399:399 $BUILD_ROOT$TOPDIR
	DEB_TRANSFORM=
	DEB_SOURCEDIR=$TOPDIR/SOURCES
	DEB_DSCFILE=$SPECFILE
	for f in $BUILD_ROOT$TOPDIR/SOURCES/debian.* ; do
	    test -f $f && DEB_TRANSFORM=true
	done
	if test -n "$DEB_TRANSFORM" ; then
	    echo "running debian transformer..."
            if ! debtransform $CHANGELOGARGS $BUILD_ROOT$TOPDIR/SOURCES $BUILD_ROOT$TOPDIR/SOURCES/$SPECFILE $BUILD_ROOT$TOPDIR/SOURCES.DEB ; then
		echo "debian transforming failed."
		cleanup_and_exit 1
	    fi
	    DEB_SOURCEDIR=$TOPDIR/SOURCES.DEB
	    for DEB_DSCFILE in $BUILD_ROOT/$DEB_SOURCEDIR/*.dsc ; do : ; done
	    DEB_DSCFILE="${DEB_DSCFILE##*/}"
        fi
	chroot $BUILD_ROOT su -c "dpkg-source -x $DEB_SOURCEDIR/$DEB_DSCFILE $TOPDIR/BUILD" - $BUILD_USER
    fi

    if test $BUILD_USER = abuild ; then
        chown -R 399:399 $BUILD_ROOT$TOPDIR/*
    else
        chown -R root:root $BUILD_ROOT$TOPDIR/*
    fi
    cd $BUILD_ROOT$TOPDIR/SOURCES || cleanup_and_exit 1

    echo -----------------------------------------------------------------
    if test "$BUILD_USER" = root ; then
        echo ----- building $SPECFILE
    else
        echo ----- building $SPECFILE "(user $BUILD_USER)"
    fi
    echo -----------------------------------------------------------------
    echo -----------------------------------------------------------------
    test -n "$RUNNING_IN_VM" && ifconfig lo 127.0.0.1 up
    test -n "$RUNNING_IN_VM" -a -n "$MYHOSTNAME" && hostname "$MYHOSTNAME"

    BUILD_SUCCEEDED=false

    if test -n "$OVERLAY" ; then
        if -d "$OVERLAY"; then
            pushd $OVERLAY
            echo "Copying overlay to BUILD_ROOT"
            tar -cpf - . | (cd $BUILD_ROOT ; tar -xvf -)
            popd
        else
            echo "OVERLAY ($OVERLAY) is no directory - skipping"
        fi
    fi

    if test -n "$RSYNCSRC" ; then
        if test -n "$RSYNCDEST"; then
            if test -d "$RSYNCSRC"; then
                if ! test -d "$BUILD_ROOT/$RSYNCDEST"; then
                    echo "ATTENTION! Creating target directory ($BUILD_ROOT/$RSYNCDEST) as its not there."
                    mkdir -p $BUILD_ROOT/$RSYNCDEST
                fi
                echo "Running rsync ..."
                rsync -av $RSYNCSRC/* $BUILD_ROOT/$RSYNCDEST/
                chown -R 399:399 $BUILD_ROOT/$RSYNCDEST
                RSYNCDONE=true
                echo "... done"
            else
                echo "RSYNCSRC is no directory - skipping"
            fi
        else
            echo "RSYNCSRC given, but not RSYNCDEST - skipping"
        fi
    fi

    # 编译 srpm
    if test "$BUILDTYPE" = spec ; then
        # 指定 rpmbuild 的编译类型，默认用 -ba
	test -z "$BUILD_RPM_BUILD_STAGE" && BUILD_RPM_BUILD_STAGE=-ba

	# XXX: move _srcdefattr to macro file?
	rpmbopts=("$BUILD_RPM_BUILD_STAGE" "--define" "_srcdefattr (-,root,root)")
	if [ -n "$ABUILD_TARGET_ARCH" ]; then
		rpmbopts[${#rpmbopts[@]}]="--target=$ABUILD_TARGET_ARCH"
	fi
	if [ -n "$BUILD_JOBS" ]; then
		rpmbopts[${#rpmbopts[@]}]='--define'
		rpmbopts[${#rpmbopts[@]}]="jobs $BUILD_JOBS"
	fi
	if [ -n "$DISTURL" ]; then
		rpmbopts[${#rpmbopts[@]}]='--define'
		rpmbopts[${#rpmbopts[@]}]="disturl $DISTURL"
	fi
	if test -s "$BUILD_ROOT/usr/lib/rpm/mandriva/macros" ; then
		rpmbopts[${#rpmbopts[@]}]='--eval'
		rpmbopts[${#rpmbopts[@]}]="%undefine _enable_debug_packages"
	fi
	if [ -n "$BUILD_DEBUG" ]; then
		rpmbopts[${#rpmbopts[@]}]='--eval'
		rpmbopts[${#rpmbopts[@]}]="%suse_insert_debug_package"
	fi
	if [ -n "$CHANGETARGET" ]; then
		rpmbopts[${#rpmbopts[@]}]='--target'
		rpmbopts[${#rpmbopts[@]}]="$CHANGETARGET"
	fi
	if [ -n "$RSYNCDONE" ] ; then
		rpmbopts[${#rpmbopts[@]}]='--define'
		rpmbopts[${#rpmbopts[@]}]="RSYNCDONE 1"
	fi

	rpmbuild=rpmbuild

	test -x $BUILD_ROOT/usr/bin/rpmbuild || rpmbuild=rpm
	# su involves a shell which would require even more
	# complicated quoting to bypass than this
        # toshellscript 是上面定义的一个函数，提供标准 shell 命令行写法，su 的情况下需要
	toshellscript $rpmbuild \
		"${definesnstuff[@]}" \
		"${rpmbopts[@]}" \
		"$TOPDIR/SOURCES/$SPECFILE" \
		> $BUILD_ROOT/.build.command
	chmod 755 $BUILD_ROOT/.build.command
        # 这里 su 命令中 -c 指定的文件就是上面 toshellscript 生成的 shell 脚本
	chroot $BUILD_ROOT su -c /.build.command - $BUILD_USER < /dev/null && BUILD_SUCCEEDED=true
    fi

    # 处理 debian
    if test "$BUILDTYPE" = dsc ; then
	# Checks to see if a build script should be used
	# this allows the build environment to be manipulated
	# and alternate build commands can be used
	DSC_BUILD_CMD="dpkg-buildpackage -us -uc -rfakeroot-tcp"
	if test -e $BUILD_ROOT/$TOPDIR/SOURCES/build.script ; then
	    echo "Sourcing build.script to build - it should normally run 'dpkg-buildpackage -us -uc -rfakeroot-tcp'"
	    DSC_BUILD_CMD="source $TOPDIR/SOURCES/build.script"
	    chmod +x $BUILD_ROOT/$TOPDIR/SOURCES/build.script
	fi
	chroot $BUILD_ROOT su -c "cd $TOPDIR/BUILD && $DSC_BUILD_CMD" - $BUILD_USER < /dev/null && BUILD_SUCCEEDED=true

	mkdir -p $BUILD_ROOT/$TOPDIR/DEBS
	for DEB in $BUILD_ROOT/$TOPDIR/*.deb ; do
	    test -e "$DEB" && mv "$DEB" "$BUILD_ROOT/$TOPDIR/DEBS"
	done
	# link sources over
	ln $BUILD_ROOT/$DEB_SOURCEDIR/$DEB_DSCFILE $BUILD_ROOT/$TOPDIR/DEBS/
	while read f ; do
	    ln $BUILD_ROOT/$DEB_SOURCEDIR/$f $BUILD_ROOT/$TOPDIR/DEBS/
	done < <(sed -ne '/^Files:/,$s/^ ................................ [0-9][0-9]* //p' < $BUILD_ROOT/$DEB_SOURCEDIR/$DEB_DSCFILE)
    fi

    # kiwi
    if test "$BUILDTYPE" = kiwi ; then
	# run createrepo on the repositories
	if test -d $BUILD_ROOT/$TOPDIR/SOURCES/repos ; then
	    (
	    ln -sf $TOPDIR/SOURCES/repos $BUILD_ROOT/repos
	    cd $BUILD_ROOT/$TOPDIR/SOURCES/repos
	    for r in */* ; do
		test -L $r && continue
		test -d $r || continue
		repo="$TOPDIR/SOURCES/repos/$r/"
		# create compatibility link
		rc="${r//:/:/}"
		if test "$rc" != "$r" ; then
		    rl="${rc//[^\/]}"
		    rl="${rl//?/../}"
		    mkdir -p "${rc%/*}"
		    ln -s $rl$r "${rc%/*}/${rc##*/}"
		    repo="$TOPDIR/SOURCES/repos/${rc%/*}/${rc##*/}/"
		fi
		echo "creating repodata for $repo"
		chroot $BUILD_ROOT createrepo "$repo"
	    done
	    )
	fi
        # unpack root tar
	for t in $BUILD_ROOT/$TOPDIR/SOURCES/root.tar* ; do
	    test -f $t || continue
	    mkdir -p $BUILD_ROOT/$TOPDIR/SOURCES/root
	    chroot $BUILD_ROOT tar -C $TOPDIR/SOURCES/root -xf "$TOPDIR/SOURCES/${t##*/}"
	done
        # fix script permissions
        chmod a+x $BUILD_ROOT/$TOPDIR/SOURCES/*.sh
	# unpack tar files in image directories
	if test -d $BUILD_ROOT/$TOPDIR/SOURCES/images ; then
	    (
	    cd $BUILD_ROOT/$TOPDIR/SOURCES/images
	    for r in */* ; do
		test -L $r && continue
		test -d $r || continue
		for t in $r/root.tar* ; do
		    test -f $t || continue
		    mkdir -p $r/root
		    chroot $BUILD_ROOT tar -C $TOPDIR/SOURCES/images/$r/root -xf "$TOPDIR/SOURCES/images/$r/${t##*/}"
		done
                # fix script permissions
                chmod a+x $BUILD_ROOT/$TOPDIR/SOURCES/images/$r/*.sh
		# create compatibility link
		rc="${r//:/:/}"
		if test "$rc" != "$r" ; then
		    rl="${rc//[^\/]}"
		    rl="${rl//?/../}"
		    mkdir -p "${rc%/*}"
		    ln -s $rl$r "${rc%/*}/${rc##*/}"
		fi
	    done
	    )
	fi
	rm -f $BUILD_ROOT/$TOPDIR/SOURCES/config.xml
	ln -s $SPECFILE $BUILD_ROOT/$TOPDIR/SOURCES/config.xml
	imagetype=$(perl -I$BUILD_DIR -MBuild::Kiwi -e Build::Kiwi::show $BUILD_ROOT/$TOPDIR/SOURCES/$SPECFILE imagetype)
	imagename=$(perl -I$BUILD_DIR -MBuild::Kiwi -e Build::Kiwi::show $BUILD_ROOT/$TOPDIR/SOURCES/$SPECFILE filename)
	imageversion=$(perl -I$BUILD_DIR -MBuild::Kiwi -e Build::Kiwi::show $BUILD_ROOT/$TOPDIR/SOURCES/$SPECFILE version)
	chroot $BUILD_ROOT su -c "kiwi --version" -
	if test "$imagetype" = product ; then
	    echo "running kiwi --create-instsource..."
	    chroot $BUILD_ROOT su -c "kiwi --root $TOPDIR/KIWIROOT -v -v --instsource-local --logfile terminal -p $TOPDIR/SOURCES --create-instsource $TOPDIR/SOURCES" - $BUILD_USER < /dev/null && BUILD_SUCCEEDED=true
	    for i in $BUILD_ROOT/$TOPDIR/KIWIROOT/main/* ; do
		test -d "$i" || continue
		n="${i##*/}"
		test "$n" = scripts && continue
		test "$n" != "${n%0}" && continue
		chroot $BUILD_ROOT su -c "suse-isolinux $TOPDIR/KIWIROOT/main/$n $TOPDIR/KIWI/$n.iso" - $BUILD_USER
	    done
	else
	    BUILD_SUCCEEDED=true
            if [ -z "$RUNNING_IN_VM" ]; then
                # NOTE: this must be done with the outer system, because it loads the dm-mod kernel modules, which needs to fit to the kernel.
                echo "starting device mapper for kiwi..."
                [ -x /etc/init.d/boot.device-mapper ] && /etc/init.d/boot.device-mapper start
            fi
	    for imgtype in $imagetype ; do
		echo "running kiwi --prepare for $imgtype..."
		if chroot $BUILD_ROOT su -c "cd $TOPDIR/SOURCES && kiwi --prepare $TOPDIR/SOURCES --logfile terminal --root $TOPDIR/KIWIROOT-$imgtype" - $BUILD_USER < /dev/null ; then
		    echo "running kiwi --create for $imgtype..."
		    mkdir -p $BUILD_ROOT/$TOPDIR/KIWI-$imgtype
		    chroot $BUILD_ROOT su -c "cd $TOPDIR/SOURCES && kiwi --create $TOPDIR/KIWIROOT-$imgtype --logfile terminal --type $imgtype -d $TOPDIR/KIWI-$imgtype" - $BUILD_USER < /dev/null || cleanup_and_exit 1
		else
                    cleanup_and_exit 1
		fi
	    done

	    # create tar.gz of images, in case it makes sense
            imagearch=`uname -m`
            buildnum=""
  	    if test -n "$RELEASE"; then
		buildnum="-Build$RELEASE"
	    fi
            for imgtype in $imagetype ; do
                case "$imgtype" in
                    oem)
            	    	pushd $BUILD_ROOT/$TOPDIR/KIWI-oem > /dev/null
                        echo "compressing images... "
                        tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-raw.tar.bz2 \
                          --exclude=$imagename.$imagearch-$imageversion.iso \
                          --exclude=$imagename.$imagearch-$imageversion.raw \
                          *
                        if [ -e $imagename.$imagearch-$imageversion.iso ]; then
                          echo "Copy iso file and create md5..."
                          mv $imagename.$imagearch-$imageversion.iso \
                             $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum.iso
            	    	  pushd $BUILD_ROOT/$TOPDIR/KIWI > /dev/null
                          md5sum $imagename.$imagearch-$imageversion$buildnum.iso \
                                 > "$imagename.$imagearch-$imageversion$buildnum.iso.md5"
                          popd > /dev/null
                        fi
                        if [ -e $imagename.$imagearch-$imageversion.raw ]; then
                          echo "Copy raw file and create md5..."
                          mv $imagename.$imagearch-$imageversion.raw \
                             $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum.raw
            	    	  pushd $BUILD_ROOT/$TOPDIR/KIWI > /dev/null
                          bzip2 $imagename.$imagearch-$imageversion$buildnum.raw && \
                          md5sum $imagename.$imagearch-$imageversion$buildnum.raw.bz2 \
                                 > "$imagename.$imagearch-$imageversion$buildnum.raw.bz2.md5"
                          popd > /dev/null
                        fi
                        popd > /dev/null
                        ;;
                    vmx)
                        pushd $BUILD_ROOT/$TOPDIR/KIWI-vmx > /dev/null
                        echo "compressing images... "
            	    	if [ -e $imagename.$imagearch-$imageversion.xenconfig ] ; then
                          tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-xenvmx.tar.bz2 \
                            $imagename.$imagearch-$imageversion.raw \
                            $imagename.$imagearch-$imageversion.xenconfig			
			else
                          tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-vmx.tar.bz2 \
                            $imagename.$imagearch-$imageversion.vmx \
                            $imagename.$imagearch-$imageversion.vmdk
            	          if [ -e $imagename.$imagearch-$imageversion.ovf ] ; then
                            tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-ovf.tar.bz2 \
                              $imagename.$imagearch-$imageversion.ovf \
                              $imagename.$imagearch-$imageversion-disk*.vmdk
            	          fi
			fi
            	    	popd > /dev/null
                        ;;
                    xen)
                        pushd $BUILD_ROOT/$TOPDIR/KIWI-xen > /dev/null
                        echo "compressing images... "
                        tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-xen.tar.bz2 \
                          `grep ^kernel $imagename.$imagearch-$imageversion.xenconfig | cut -d'"'  -f2` \
                          `grep ^ramdisk $imagename.$imagearch-$imageversion.xenconfig | cut -d'"'  -f2` \
                          $imagename.$imagearch-$imageversion.xenconfig \
                          $imagename.$imagearch-$imageversion
            	    	popd > /dev/null
                        ;;
                    pxe)
                        pushd $BUILD_ROOT/$TOPDIR/KIWI-pxe > /dev/null
                        echo "compressing images... "
                        tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-pxe.tar.bz2 \
                          $imagename.$imagearch-$imageversion.config \
                          $imagename.$imagearch-$imageversion.md5 \
                          $imagename.$imagearch-$imageversion.gz \
                          initrd-*
            	    	popd > /dev/null
                        ;;
                    iso)
                        pushd $BUILD_ROOT/$TOPDIR/KIWI-iso > /dev/null
                        echo "creating md5 sum for iso images... "
            	        for i in *.iso; do
                          pushd $BUILD_ROOT/$TOPDIR/KIWI/ > /dev/null
              	          mv $BUILD_ROOT/$TOPDIR/KIWI-iso/$i ${i%.iso}$buildnum.iso
              	          md5sum ${i%.iso}$buildnum.iso > ${i%.iso}$buildnum.iso.md5
            	    	  popd > /dev/null
                        done
            	    	popd > /dev/null
                        ;;
                    *)
                        pushd $BUILD_ROOT/$TOPDIR/KIWI-$imgtype > /dev/null
                        echo "compressing unkown images... "
                        tar cvjfS $BUILD_ROOT/$TOPDIR/KIWI/$imagename.$imagearch-$imageversion$buildnum-$imgtype.tar.bz2 \
                          *
            	    	popd > /dev/null
                        ;;
                esac
            done
	fi
    fi

    test "$BUILD_SUCCEEDED" = true || cleanup_and_exit 1
    test -d "$SRCDIR" && cd "$SRCDIR"
done

# 保存 debs 和 rpms 列表
RPMS=`find $BUILD_ROOT/$TOPDIR/RPMS -type f -name "*.rpm" 2>/dev/null`
DEBS=`find $BUILD_ROOT/$TOPDIR/DEBS -type f -name "*.deb" 2>/dev/null`

if test -n "$RPMS" -a -n "$BUILD_USER_ABUILD_USED" ; then
    echo "... checking for files with abuild user/group"
    BADFILE=
    while read un gn fn ; do
	if test "$un" = abuild -o "$gn" = abuild -o "$un" = 399 -o "$gn" = 399 ; then
	    echo "  $un $gn $fn"
	    BADFILE=true
	fi
    done < <(rpm -qp --qf '[%{FILEUSERNAME} %{FILEGROUPNAME} %{FILENAMES}\n]' $RPMS)
    if test -n "$BADFILE" ; then
	echo "please fix your filelist (e.g. add defattr)"
	cleanup_and_exit 1
    fi
fi

if test -n "$RPMS" -a -d "$BUILD_ROOT/usr/lib/build/checks" ; then
    mount -n -tproc none $BUILD_ROOT/proc 2> /dev/null
    export PNAME=""
    export DO_RPM_REMOVE=true
    for SRPM in $BUILD_ROOT/$TOPDIR/SRPMS/*src.rpm ; do
	test -f "$SRPM" && PNAME=`rpm --nodigest --nosignature -qp --qf "%{NAME}" $SRPM`
    done
    for CHECKSCRIPT in $BUILD_ROOT/usr/lib/build/checks/* ; do
	echo "... running `basename $CHECKSCRIPT`"
	$CHECKSCRIPT || cleanup_and_exit 1
    done
    umount -n $BUILD_ROOT/proc 2> /dev/null
fi

if test -n "$RPMS" -a "$DO_CHECKS" != "false" -a -x "$BUILD_ROOT/opt/testing/bin/rpmlint" -a -d "$BUILD_ROOT/$TOPDIR/RPMS" ; then
    LINT_RPM_FILE_LIST=($(find $BUILD_ROOT/$TOPDIR/RPMS \
        \( -name "*-debuginfo-*" -o -name "*-debugsource-*" \
        -o -name "*-32bit-*" -o -name "*-64bit-*" \
        -o -name "*-x86-*" -o -name "*-ia32-*" \) -prune \
        -o -type f -name '*.rpm' -print))
    SRPM_FILE_LIST=($(find $BUILD_ROOT/$TOPDIR/SRPMS -type f -name "*.rpm"))
    echo
    echo "RPMLINT report:"
    echo "==============="
    chroot $BUILD_ROOT /opt/testing/bin/rpmlint --info ${LINT_RPM_FILE_LIST[*]#$BUILD_ROOT} ${SRPM_FILE_LIST[*]#$BUILD_ROOT} || cleanup_and_exit 1
fi

if test \( -n "$RPMS" -o -n "$DEBS" \) -a -n "$CREATE_BASELIBS" -a \( -d "$BUILD_ROOT/$TOPDIR/RPMS" -o -d "$BUILD_ROOT/$TOPDIR/DEBS" \)  ; then
    if test -f $BUILD_ROOT/usr/lib/build/mkbaselibs -o "$CREATE_BASELIBS" != internal ; then
	mount -n -tproc none $BUILD_ROOT/proc 2> /dev/null
	create_baselibs
	umount -n $BUILD_ROOT/proc 2> /dev/null
    fi
fi

# IMPLEMENT ME: place code for creating binary package deltas here

if test -n "$RUNNING_IN_VM" -a -n "$VM_SWAP"; then
    echo "... saving built packages"
    swapoff "$VM_SWAP"
    args="--padstart 512 --padend 512 -v"
    case "$BUILDTYPE" in
	spec)
	    computeblocklists $args $TOPDIR/RPMS/*/*.rpm $TOPDIR/SRPMS/* > "$VM_SWAP"
	    ;;
	dsc)
	    computeblocklists $args $TOPDIR/DEBS/*.deb $TOPDIR/SOURCES.DEB/* > "$VM_SWAP"
	    ;;
	kiwi)
	    computeblocklists $args $TOPDIR/KIWI/* > "$VM_SWAP"
	    ;;
    esac || cleanup_and_exit 1
fi

if test -n "$RPMS" -a -d "$BUILD_ROOT/$TOPDIR/RPMS" -a -d "$BUILD_ROOT/.build.oldpackages" -a -x "$BUILD_ROOT/usr/lib/build/same-build-result.sh" ; then
    echo "... comparing built packages with the former built"
    # exit with 2, if packages built successfull, but have no changes to former built packages.
    mount -n -tproc none $BUILD_ROOT/proc 2> /dev/null
    chroot $BUILD_ROOT /usr/lib/build/same-build-result.sh /.build.oldpackages "$TOPDIR/RPMS" "$TOPDIR/SRPMS" && cleanup_and_exit 2
    umount -n $BUILD_ROOT/proc 2> /dev/null
fi

echo
echo "$HOST finished \"build $SPECFILE\" at `date`."
echo

cleanup_and_exit 0
